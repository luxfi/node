diff --git a/vms/cchainvm/backend.go b/vms/cchainvm/backend.go
index abc123..def456 100644
--- a/vms/cchainvm/backend.go
+++ b/vms/cchainvm/backend.go
@@ -46,48 +46,104 @@ type MinimalEthBackend struct {
 // NewMigratedBackend creates a special backend for fully migrated data
 // This completely bypasses genesis initialization
 func NewMigratedBackend(db ethdb.Database, migratedHeight uint64) (*MinimalEthBackend, error) {
-	fmt.Printf("Creating migrated backend for height %d\n", migratedHeight)
+	fmt.Printf("Creating migrated backend for subnet-EVM data at height %d\n", migratedHeight)
 	
-	// Create a minimal chain config
+	// Create chain config for LUX mainnet
 	chainConfig := &params.ChainConfig{
 		ChainID:                 big.NewInt(96369),
-		HomesteadBlock:          big.NewInt(0),
-		EIP150Block:             big.NewInt(0),
-		EIP155Block:             big.NewInt(0),
-		EIP158Block:             big.NewInt(0),
-		ByzantiumBlock:          big.NewInt(0),
-		ConstantinopleBlock:     big.NewInt(0),
-		PetersburgBlock:         big.NewInt(0),
-		IstanbulBlock:           big.NewInt(0),
-		BerlinBlock:             big.NewInt(0),
-		LondonBlock:             big.NewInt(0),
+		HomesteadBlock:          common.Big0,
+		EIP150Block:             common.Big0,
+		EIP155Block:             common.Big0,
+		EIP158Block:             common.Big0,
+		ByzantiumBlock:          common.Big0,
+		ConstantinopleBlock:     common.Big0,
+		PetersburgBlock:         common.Big0,
+		IstanbulBlock:           common.Big0,
+		BerlinBlock:             common.Big0,
+		LondonBlock:             common.Big0,
 		TerminalTotalDifficulty: common.Big0,
 	}
 	
 	// Create a dummy consensus engine
 	engine := &dummyEngine{}
 	
-	// For subnet-EVM databases, scan for blocks by hash encoding
-	var headHash common.Hash
-	blockFound := false
-	
 	// Subnet-EVM namespace
 	namespace := []byte{
 		0x33, 0x7f, 0xb7, 0x3f, 0x9b, 0xcd, 0xac, 0x8c,
 		0x31, 0xa2, 0xd5, 0xf7, 0xb8, 0x77, 0xab, 0x1e,
 		0x8a, 0x2b, 0x7f, 0x2a, 0x1e, 0x9b, 0xf0, 0x2a,
 		0x0a, 0x0e, 0x6c, 0x6f, 0xd1, 0x64, 0xf1, 0xd1,
 	}
 	
-	fmt.Printf("Scanning for block %d using subnet-EVM hash encoding...\n", migratedHeight)
+	fmt.Printf("Scanning subnet-EVM database for blocks...\n")
 	
-	// Create an iterator to scan the database
+	// Build block index first
+	blocksByNumber := make(map[uint64]common.Hash)
+	headersByHash := make(map[common.Hash][]byte)
 	iter := db.NewIterator(nil, nil)
-	defer iter.Release()
 	
-	blocksFound := 0
 	for iter.Next() {
 		key := iter.Key()
 		value := iter.Value()
 		
+		// Check for namespace + 32-byte hash format
+		if len(key) == 64 && bytes.Equal(key[:32], namespace) {
+			hash := key[32:]
+			
+			// Check if value is RLP header
+			if len(value) > 100 && (value[0] == 0xf8 || value[0] == 0xf9) {
+				// Decode block number from first 3 bytes of hash
+				blockNum := uint64(hash[0])<<16 | uint64(hash[1])<<8 | uint64(hash[2])
+				
+				var h common.Hash
+				copy(h[:], hash)
+				blocksByNumber[blockNum] = h
+				headersByHash[h] = value
+				
+				if len(blocksByNumber) <= 10 || len(blocksByNumber)%100000 == 0 {
+					fmt.Printf("  Found block %d at hash %x\n", blockNum, hash[:8])
+				}
+			}
+		}
+	}
+	iter.Release()
+	
+	fmt.Printf("Found %d blocks in subnet-EVM database\n", len(blocksByNumber))
+	
+	// Find the requested block or highest available
+	var headHash common.Hash
+	var actualHeight uint64
+	
+	if hash, exists := blocksByNumber[migratedHeight]; exists {
+		headHash = hash
+		actualHeight = migratedHeight
+	} else {
+		// Find highest block
+		for num, hash := range blocksByNumber {
+			if num > actualHeight {
+				actualHeight = num
+				headHash = hash
+			}
+		}
+		fmt.Printf("Block %d not found, using highest block %d\n", migratedHeight, actualHeight)
+	}
+	
+	if headHash == (common.Hash{}) {
+		return nil, fmt.Errorf("no blocks found in subnet-EVM database")
+	}
+	
+	fmt.Printf("Setting head to block %d with hash: %x\n", actualHeight, headHash)
+	
+	// Write canonical mappings in standard format
+	rawdb.WriteCanonicalHash(db, headHash, actualHeight)
+	rawdb.WriteHeadBlockHash(db, headHash)
+	rawdb.WriteHeadHeaderHash(db, headHash)
+	rawdb.WriteHeadFastBlockHash(db, headHash)
+	rawdb.WriteLastPivotNumber(db, actualHeight)
+	
+	// Also write canonical mapping for all blocks we found
+	fmt.Printf("Writing canonical mappings for %d blocks...\n", len(blocksByNumber))
+	for blockNum, hash := range blocksByNumber {
+		rawdb.WriteCanonicalHash(db, hash, blockNum)
+	}
+	
 		// Check for namespace + 32-byte hash format
 		if len(key) == 64 && bytes.Equal(key[:32], namespace) {
 			hash := key[32:]

diff --git a/vms/cchainvm/database.go b/vms/cchainvm/database.go
index abc123..def456 100644
--- a/vms/cchainvm/database.go
+++ b/vms/cchainvm/database.go
@@ -4,6 +4,7 @@
 package cchainvm
 
 import (
+	"bytes"
 	"encoding/binary"
 	"errors"
 	"fmt"
@@ -12,12 +13,23 @@ import (
 	"github.com/luxfi/database"
 )
 
+// Subnet-EVM namespace for LUX mainnet
+var subnetNamespace = []byte{
+	0x33, 0x7f, 0xb7, 0x3f, 0x9b, 0xcd, 0xac, 0x8c,
+	0x31, 0xa2, 0xd5, 0xf7, 0xb8, 0x77, 0xab, 0x1e,
+	0x8a, 0x2b, 0x7f, 0x2a, 0x1e, 0x9b, 0xf0, 0x2a,
+	0x0a, 0x0e, 0x6c, 0x6f, 0xd1, 0x64, 0xf1, 0xd1,
+}
+
+// Flag to enable subnet namespace handling (set when using --genesis-db)
+var useSubnetNamespace = false
+
 // canonicalKey returns the standard C-chain canonical key format:
 //   "H" + blockNumber (8 bytes)
 func canonicalKey(number uint64) []byte {
 	key := make([]byte, 9)
 	key[0] = 'H'
 	binary.BigEndian.PutUint64(key[1:], number)
 	return key
 }
 
@@ -38,11 +50,65 @@ func (d *DatabaseWrapper) Has(key []byte) (bool, error) {
 
 // Get retrieves the given key if it's present in the key-value data store
 func (d *DatabaseWrapper) Get(key []byte) ([]byte, error) {
-	// Debug specific keys (9-byte canonical format)
-	if len(key) > 0 && key[0] == 'H' && len(key) == 9 {
-		val, err := d.db.Get(key)
-		fmt.Printf("Debug: Reading canonical hash key: %x value: %x err: %v\n", key, val, err)
-		return val, err
+	// Handle subnet-EVM namespaced keys when flag is set
+	if useSubnetNamespace {
+		// For canonical hash lookups (H prefix, 9 bytes)
+		if len(key) == 9 && key[0] == 'H' {
+			// First try standard format
+			val, err := d.db.Get(key)
+			if err == nil {
+				return val, nil
+			}
+			
+			// If not found, scan for block by number encoded in hash
+			blockNum := binary.BigEndian.Uint64(key[1:])
+			iter := d.db.NewIterator(nil, nil)
+			defer iter.Release()
+			
+			for iter.Next() {
+				k := iter.Key()
+				v := iter.Value()
+				
+				if len(k) == 64 && bytes.Equal(k[:32], subnetNamespace) {
+					hash := k[32:]
+					if len(v) > 100 && (v[0] == 0xf8 || v[0] == 0xf9) {
+						// Decode block number from first 3 bytes of hash
+						hashBlockNum := uint64(hash[0])<<16 | uint64(hash[1])<<8 | uint64(hash[2])
+						if hashBlockNum == blockNum {
+							// Return the hash for this block number
+							return hash, nil
+						}
+					}
+				}
+			}
+			return nil, database.ErrNotFound
+		}
+		
+		// For header/body lookups (h/b prefix + 32-byte hash)
+		if len(key) == 33 && (key[0] == 'h' || key[0] == 'b') {
+			// Try standard format first
+			val, err := d.db.Get(key)
+			if err == nil {
+				return val, nil
+			}
+			
+			// Try with namespace for header
+			if key[0] == 'h' {
+				nsKey := make([]byte, 64)
+				copy(nsKey[:32], subnetNamespace)
+				copy(nsKey[32:], key[1:])
+				val, err := d.db.Get(nsKey)
+				if err == nil {
+					return val, nil
+				}
+			}
+		}
+		
+		// For direct hash lookups (32 bytes)
+		if len(key) == 32 {
+			nsKey := make([]byte, 64)
+			copy(nsKey[:32], subnetNamespace)
+			copy(nsKey[32:], key)
+			return d.db.Get(nsKey)
+		}
 	}
 	return d.db.Get(key)
 }

diff --git a/vms/cchainvm/vm.go b/vms/cchainvm/vm.go
index abc123..def456 100644
--- a/vms/cchainvm/vm.go
+++ b/vms/cchainvm/vm.go
@@ -100,6 +100,20 @@ func (vm *VM) Initialize(
 	// Create a database wrapper first
 	vm.ethDB = WrapDatabase(cchainDB)
 	
+	// Check for --genesis-db flag to enable subnet namespace handling
+	if genesisDBPath := os.Getenv("GENESIS_DB"); genesisDBPath != "" {
+		fmt.Printf("Genesis DB path provided: %s\n", genesisDBPath)
+		
+		// Check if this is a subnet-EVM database by looking for namespace pattern
+		testIter := vm.ethDB.NewIterator(nil, nil)
+		if testIter.Next() && len(testIter.Key()) == 64 {
+			// This looks like a namespaced database
+			useSubnetNamespace = true
+			fmt.Println("Detected subnet-EVM database format, enabling namespace handling")
+		}
+		testIter.Release()
+	}
+	
 	// Check for migrated data by looking for a LastBlock key
 	if val, err := cchainDB.Get([]byte("LastBlock")); err == nil && len(val) == 32 {
 		hasMigratedData = true