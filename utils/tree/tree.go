// Copyright (C) 2020-2025, Lux Industries Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package tree

import (
	"context"

	"golang.org/x/exp/maps"

	"github.com/luxfi/ids"
	chaincon "github.com/luxfi/node/quasar/chain"
)

// Tree handles the propagation of block acceptance and rejection to inner
// blocks.
//
// The Tree is needed because:
// 1. The consensus engine guarantees that for each verified block, either
// Accept() or Reject() are eventually called, and they are called only once.
// The proposervm must maintain these invariants for the wrapped VM.
// 2. A given inner block may be wrapped into multiple different proposervm
// blocks (e.g. same inner block generated by two validators).
//
// The Tree prevents Accept() and Reject() from being called multiple times on
// the same inner block by:
// 1. tracking inner blocks in a tree-like structure, to be able to easily spot
// siblings
// 2. rejecting an inner block only when one of the siblings is accepted.
// Rejection of a proposervm block does not imply its inner block rejection
// (it may be held by a different proposervm block).
type Tree interface {
	// Add places the block in the tree
	Add(chaincon.Block)

	// Get returns the block that was added to this tree whose parent and ID
	// match the provided block. If non-exists, then false will be returned.
	Get(chaincon.Block) (chaincon.Block, bool)

	// Accept marks the provided block as accepted and rejects every conflicting
	// block.
	Accept(context.Context, chaincon.Block) error
}

type tree struct {
	// parentID -> childID -> childBlock
	nodes map[ids.ID]map[ids.ID]chaincon.Block
}

func New() Tree {
	return &tree{
		nodes: make(map[ids.ID]map[ids.ID]chaincon.Block),
	}
}

func (t *tree) Add(blk chaincon.Block) {
	parentID := blk.Parent()
	children, exists := t.nodes[parentID]
	if !exists {
		children = make(map[ids.ID]chaincon.Block)
		t.nodes[parentID] = children
	}
	blkIDStr := blk.ID()
	// Convert string ID to ids.ID
	var blkID ids.ID
	copy(blkID[:], []byte(blkIDStr))
	children[blkID] = blk
}

func (t *tree) Get(blk chaincon.Block) (chaincon.Block, bool) {
	parentID := blk.Parent()
	children := t.nodes[parentID]
	blkIDStr := blk.ID()
	// Convert string ID to ids.ID
	var blkID ids.ID
	copy(blkID[:], []byte(blkIDStr))
	originalBlk, exists := children[blkID]
	return originalBlk, exists
}

func (t *tree) Accept(ctx context.Context, blk chaincon.Block) error {
	// accept the provided block
	if err := blk.Accept(); err != nil {
		return err
	}

	// get the siblings of the block
	parentID := blk.Parent()
	children := t.nodes[parentID]
	blkIDStr := blk.ID()
	// Convert string ID to ids.ID
	var blkID ids.ID
	copy(blkID[:], []byte(blkIDStr))
	delete(children, blkID)
	delete(t.nodes, parentID)

	// mark the siblings of the accepted block as rejectable
	childrenToReject := maps.Values(children)

	// reject all the rejectable blocks
	for len(childrenToReject) > 0 {
		i := len(childrenToReject) - 1
		child := childrenToReject[i]
		childrenToReject = childrenToReject[:i]

		// reject the block
		if err := child.Reject(); err != nil {
			return err
		}

		// mark the progeny of this block as being rejectable
		childIDStr := child.ID()
		// Convert string ID to ids.ID
		var childID ids.ID
		copy(childID[:], []byte(childIDStr))
		childrenOfChild := t.nodes[childID]
		childrenToReject = append(childrenToReject, maps.Values(childrenOfChild)...)
		delete(t.nodes, childID)
	}
	return nil
}
